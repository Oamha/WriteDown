## Java虚拟机的相关总结
1、JDK包含了Java语言，Java虚拟机和Java API类库；

2、JRE包含了Java API中的Java SE API子集和Java虚拟机；

3、常见的Java虚拟机：HotSpot（Oracle）、J9 VM（IBM）、Zing VM；

4、Java虚拟机和Java语言没有什么联系，只与特定的二进制文件有关（class文件）；

5、Java虚拟机包含运行时数据区，执行引擎，本地库接口，本地方法库；

6、类加载子系统不属于Java虚拟机的内部结构；

7、运行时数据区包含方法区、Java虚拟机栈、本地方法栈、Java堆，程序计数器；

8、方法区和Java堆是线程共享的，

9、执行引擎包含即时编译器、垃圾回收器；

10、类的生命周期：加载、链接（验证、准备和解析）、初始化、使用和卸装；
+ 加载：查找并加载class文件；
+ 链接：包括验证，准备和解析；
+ 验证：确保被导入类型的正确性；
+ 准备：为类的静态字段分配内存空间，并用默认值初始化这些字段；
+ 解析：虚拟机将常量池内的符号应用替换为直接饮用；

11、类加载子系统通过多种类加载器来查找和加载class文件到Java虚拟机中；

12、Java虚拟机有两种类加载器：系统类加载器和自定义类加载器；

13、系统类加载器：
+ Bootstrap ClassLoader 用于加载指定JDK的核心类库，比如java.lang,java.util等，它用来加载$JAVA_HOME/jre/bin目录下的类；
+ Extension ClassLoader 用于加载Java的拓展类，主要加载$JAVA_HOME/jre/lib/ext目录；
+ Application ClassLoader 又称系统类加载器，主要加载当前应用程序的classpath目录；

14、自定义类加载器可以通过继承java.lang.ClassLoader来实现；

15、运行时数据区包含：
+ 程序计数器：每个线程都有一个程序计数器来记录下一条需要执行的字节码指令；如果线程执行的不是native方法，则程序计数器保存的是正在执行的字节码指令地址，如果是native方法，则程序计数器的值为空（undefined）；
+ Java堆：Java堆用来存放对象实例，几乎所有的对象实例都在这里进行分配回收，是垃圾收集器管理的主要区域；
+ 方法区：用来存储已经被Java虚拟机加载的类的结构信息，包括运行时常量池，字段和方法信息、静态变量等数据；方法区包含运行时常量池，运行时常量池用来保存编译时期生成的字面量和符号应用；
+ Java虚拟机栈：用来存储线程中Java方法调用的状态，包括局部变量，参数，返回值以及运算的中间结果。Java虚拟机栈包含很多栈帧，一个栈帧用来存储局部变量表，操作数栈，动态链接、方法出口等信息；
+ 本地方法栈：用来支持native方法的执行，HotSpot VM将本地方法栈和虚拟机栈合二为一；
16、对象的创建过程
+ 判断对象对应的类是否被加载、链接和初始化，接受new指令时，检查这个指定的参数是否能在常量池中定位到一个类，并检查这个符号引用代表的类是否已被类加载器加载、链接和初始化；
+ 为对象分配内存，内存分配根据内存是否规整存在两种方式：内存规整使用指针碰撞（空闲内存在一侧，用过的内存在另一侧），否则使用空闲列表（维护一个列表记录哪些内存是可用的）；
+ 处理并发问题，有两种方式：A对分配内存的操作进行同步处理，在虚拟机中采用CAS算法并配上失败重试的机制；B 在Java堆中预先分配一块内存，称作本地线程分配缓冲，线程需要分配内存时，就在对应线程的TLAB上分配内存；
+ 初始化分配到的内存空间：将分配到的内存，除了对象头外都初始化为零值；
+ 设置对象的对象头：将对象的HashCode和GC分代年龄等数据存储在对象头；
+ 执行init方法进行初始化：初始化对象的成员变量、调用类的构造方法；

17、对象的堆内存分布
    + 对象头 分为两部分（Mark World和元数据指针）：Mark World用于存储对象运行时数据，比如hashcode，锁状态标志，GC分代年龄，线程持有的锁；元数据指针用于指向方法区中的目标类的元数据，通过元数据可以确定对象的具体类型；
    + 实例数据 存储对象中各种类型的字段信息（包括从父类继承来的）；
    + 对齐填充 不一定存在，起占位作用；

18、Java中的引用
+ 强引用：虚拟机宁愿抛出OutOfMemoryError，也不会回收强引用；
+ 软引用：内存不够时才会回收只具有软引用的对象；
+ 弱引用：垃圾收集器一旦发现了只具有弱引用的对象，不管内存是否足够，都会回收它的内存；
+ 虚引用：跟没有引用一样，任何时候都可能被回收，被回收时会收到通知；

19、垃圾标记算法
+ 引用计数法（无法解决循环依赖问题）；
+ 根搜索算法

20、Java对象在虚拟机中的生命周期
+ 创建阶段
+ 应用阶段 至少有一个引用
+ 不可见阶段 找不到对象的任何强引用，比如被运行中的线程引用
+ 不可达阶段 找不到任何强引用，垃圾收集器发现其不可达
+ 收集阶段 垃圾收集器准备对其内存空间进行重新分配，如果重写了finalize方法，则会调用该方法；
+ 终结阶段 没有重写finalize或者执行完finalize后仍然处于不可达状态，进入终结阶段
+ 对象空间重新分配阶段 

21、垃圾收集算法
+ 标记清除算法 标记清除效率都不高，容易产生大量内存碎片
+ 复制算法 代价是可用内存减少一半，效率跟存活对象的数目有关，广泛应用于新生代
+ 标记压缩算法 广泛用于老年代
+ 分代收集算法 Java堆区分为新生代和老年代，新生代又划分为Eden，From Survivor、To Survivor，Eden和Survivor比例8:1；分代收集分为两种：
    - Minor Collection: 新生代垃圾收集，Minor Collection时，Eden空间的存活对象会被复制到To Survivor空间，之前经过一次Minor Collection并在From Survivor空间存活的仍年轻的对象也会复制到To Survivor空间；当To Survivor空间容量达到阈值时，这时意味着Eden和From Survivor空间剩下的都是可回收对象，这时会执行Minor Collection，清空Eden和From Survivor，新生代存活的对象都存放在To Survivor中，这时将From Survivor和To Survivor互换，这就是复制算法在新生代的应用；
    - Full Collection：老年代收集，又称为Major Collection，一次Full Collection通常伴随至少一次Minor Collection，收集频率较低，耗时较长
