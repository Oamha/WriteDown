## 运行期优化
### 1、逃逸分析
```java
public class RuntimeOptimize1 {
    //-XX:+PrintCompilation -XX:-DoEscapeAnalysis
    public static void main(String[] args) {
        for (int i = 0; i < 200; i++) {
            long start = System.nanoTime();
            for (int j = 0; j < 10000; j++) {
                new Object();
            }
            System.out.printf("%d---%d\n", i, (System.nanoTime() - start));
        }
    }
}
```
运行结果：
```java
0---673900
1---286100
2---281900
3---284200
4---583800
5---276200
6---294800
7---2667100
8---121900
9---388700
10---4808300
11---3700
12---3700
13---3700
14---3700
15---3700
16---3700
17---3700
18---3600
19---3700
20---3700
21---3600
22---3700
23---3700
24---3700
25---3600
26---3700
27---3700
28---3700
29---3700
30---3600
31---3700
32---3700
33---3700
34---3600
35---3700
36---3600
37---6100
38---3700
39---3600
40---3700
41---3700
42---3700
43---3800
44---3700
45---3700
46---3600
47---3700
48---3600
49---3600
```
可以看到程序运行一段时间后，内层循环的消耗的时间明显减少，这是因为Java虚拟机存在运行时优化，针对这个例子，采用的是逃逸分析优化，发现新建的对象压根没被外部使用，所以JVM会将创建对象的代码优化掉；<br/>
JVM 将执行状态分成了 5 个层次：
+ 0层，解释执行;
+ 1层，使用C1即时编译器编译执行（不带 profiling）;
+ 2层，使用C1即时编译器编译执行（带基本的 profiling）;
+ 3层，使用C1即时编译器编译执行（带完全的 profiling）;
+ 4层，使用C2即时编译器编译执行;

即时编译器（JIT）与解释器的区别
+ 解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释，解释器是将字节码解释为针对所有平台都通用的机器码；
+ JIT是将一些字节码编译为机器码，并存入Code Cache，下次遇到相同的代码，直接执行，无需再编译，JIT 会根据平台类型，生成平台特定的机器码；

对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。执行效率上简单比较一下 Interpreter<C1<C2，总的目标是发现热点代码（hotspot名称的由来）。