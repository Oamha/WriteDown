## TCP传输控制协议
### 1、特点
+ TCP是面向连接的运输层协议；
+ TCP能够提供可靠交付，能够保证无差错，不重复，不丢失，不乱序；
+ TCP是面向字节流的；
+ TCP要建立Socket连接，而UDP不需要；

### 2、TCP实现可靠传输的原理
#### 2.1、停止等待协议
::: tip 概念
停止等待协议顾名思义就是每发送一个分组就停止发送，等待对方的确认，在收到确认之后再发送下一个分组，不过该种协议效率太低，所以在运输层并没有得到应用。
:::
#### 2.2、连续ARQ(Automatic Repeat reQuest)
::: tip 概念
连续ARQ可以看成是流水线式的停止等待协议，发送方可以连续发送多个分组，不必每发送一个分组就停下来等待对方的确认，因而可以获得更高的信道利用率；
:::
连续ARQ内部维持了一个滑动窗口，窗口内的分组是可以发送的分组，每收到一个对窗口内分组的确认，滑动窗口就可以前移一个分组的位置。接收方收到分组后也不用逐个进行确认，可以进行累积确认；
### 3、TCP首部格式
TCP首部固定部分是20字节，选项部分可以根据需要来增加<br/>
<Common-Thumb :prefix="'/img/theory/computer-network'" :urls="'tcp_header.jpg'"/>
+ 源端口、目标端口分别占用2字节；
+ 序号占用4字节，该字段值是本报文段所发送数据的第一个字节的编号；
+ 确认号占用4字节，该字段值表示期望收到对方下一个报文段的第一个数据字节的序号，假设确认号为N，则表示到N-1为止的数据已经收到；
+ 数据偏移占用4位，但单位为4字节，该字段表示TCP头部的大小，最大为60字节；
+ 保留位占用6位，用于今后使用；
+ 紧急URG 为1时表示有紧急数据需要发送，可以将待发送紧急数据插入报文段最前面。需要配置紧急指针字段使用。
+ 确认ACK 为1时确认号字段才有效；
+ 推送PSH 用于交互式推送服务，PSH为1时，立即创建一个报文进行发送，接收方收到后，也尽快进行上层交付；
+ 复位RST 用于连接出错时进行重置；
+ 同步SYN SYN为1，ACK为0表示连接请求；SYN为1，ACK为1表示同意建立连接；
+ 终止FIN 用于释放一个连接；
+ 窗口 占用两字节 可以让发送方根据接收方当前的接收能力设置发送窗口的大小，避免发送太快，处理不了；
+ 校验和 占用2字节，和UDP校验和类似，只是计算时伪首部的协议号要改成6，大小改成TCP报文的大小；
+ 紧急指针 占用2字节，用于指明紧急数据的偏移（紧急数据的字节数）；
+ 选型 最长40字节，用于增加一些扩充属性，如Selective ACK（选择确认），窗口扩大选项等；
### 4、TCP可靠传输的实现
#### 4.1 超时重传时间的选择
::: tip 概念
重传的概念很简单，但重传时间的选择很复杂。如果重传时间设置的过大，则会使网络传输效率降低；如果设置的过小，则会造成不必要的重传，使网络负载加重。
:::
#### 4.2 重传时间的计算
+ RTT 报文段从发出到确认所经历的时间
+ RTT<sub>s</sub> 加权平均往返时间，个人理解相当于把往返时间变得稳定点，不至于波动太大。<br/>
<b>计算方式如下：</b><br/>
<b>新的RTT<sub>s</sub> = ( 1 - α ) * 旧的RTT<sub>s</sub> + α * 新的RTT样本</b> <br/>
<b>α建议为0.125，如果是第一次，那么RTT<sub>s</sub>取值就为RTT</b>
+ RTT<sub>D</sub> RTT的偏差的加权平均值 <br/>
<b>计算方式如下：</b><br/>
<b>新的RTT<sub>D</sub> = (1 - β) * 旧的RTT<sub>D</sub> + β * | RTT<sub>S</sub> - 新的RTT样本|</b> <br/>
β建议为0.25， 如果是第一次，RTT<sub>D</sub>为测量到的RTT样本值的一半
+ RTO 超时重传时间 </br>
<b>计算方式如下：</b><br/>
<b>RTO = RTT<sub>s</sub> + 4 * RTT<sub>D</sub></b>

#### 4.3 选择确认SACK（Selective ACK）
::: tip 概念
对于未按顺序到达的分组，我们可以选择不丢弃，而是暂时保存，并向发送方指明收到数据块的边界，以此判断哪些数据没有收到，然后只需要发送方重传缺少的数据；
:::
+ SACK要在建立连接时进行协商，在选项字段中增加SACK选项。
+ 选型字段最大40字节，所以最多向发送方报告4个不连续的字节块的边界。4个字节块8个边界，总共32个字节，再加上SACK选项一字节，和指明SACK选项总共占用要用1字节；
### 5、TCP流量控制
::: tip 概念
接收方通过设置TCP报文段首部的窗口值来向发送方表明自己的接收能力，发送方根据这个窗口值设置自己的发送窗口的大小，从而确保发送窗口不会大于接收窗口。
::: 
注意：接收窗口可以为零，当接收窗口为零时，发送方不可以再发送数据。
当发送方收到零窗口通知时，会启动一个持续计时器，定时发送一个零窗口探测报文段，这是为了防止接收方发送的非零窗口报文丢失，导致发送方一直处于等待状态。
### 6、TCP拥塞控制
::: tip 概念
TCP的拥塞控制目的是防止过多的数据注入到网络中，这样可以使网络中的路由器和链路不至于过载。而流量控制的目的是抑制发送端发送数据的速率，以便使接收端能够来得及接收。
:::
+ 慢开始

慢开始的思想是：当主机开始发送数据时，由于并不知道网络的负载情况，所以如果立即将大量数据字节注入到网络，那么就有可能引发网络拥塞，经验证，最好的方式是先探测一下，由小到大增大发送窗口。先设置cwnd=1，每收到一个分组的确认，就将cwnd加一，比如起初cwnd=1，发送M1报文段，收到M1的确认报文后，将cwnd加一，cwnd=2，此时可以发送M2，M3报文段，收到M2、M3的确认报文后，将cwnd加二，cwnd=4，可以发送M4、M5、M6、M7，以此类推，每经过一个传播轮次，拥塞窗口cwnd就翻倍。
+ 拥塞避免

当然，不可能让慢开始的cwnd无限增长，要设置一个慢开始门限值ssthresh，当cwnd < ssthresh时，使用慢开始算法，当cwnd > ssthresh时，使用拥塞避免算法，拥塞避免算法的思想是让拥塞窗口缓慢增加，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加一，而不是像慢开始阶段那样成倍增长。当发生超时时，调整门限值ssthresh = cwnd/2，cwnd = 1，然后开始慢开始算法。
+ 快重传

拥塞发生的标志就是出现了超时。当个别报文丢失时，可能并不是网络拥塞导致的，这时如果什么都不做，就会出现超时，发送方就会以为出现了网络拥塞而去启动慢开始，将cwnd置为1，这样会大大降低传输效率。解决方法就是使用快重传。假设接收方确认了M2，丢失了M3，那么后续接收到M4、M5、M6报文时，仍然需要重复确认M2，这样就产生了4个对M2的确认，后3个都是重复确认，发送方收到3个重复确认，就知道接收方确实没收到报文M3，因而应当进行快重传。快重传要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。

+ 快恢复

由于只是丢失了个别报文段，所以没必要开始慢开始算法，而是执行快恢复算法。调整门限值ssthresh = cwnd/2，设置cwnd = ssthresh，然后执行拥塞避免算法。

<Common-Thumb :prefix="'/img/theory/computer-network'" :urls="'congestion-control.jpg'"/>
### 7、TCP的连接管理
#### 7.1 三报文握手建立连接
<Common-Thumb :prefix="'/img/theory/computer-network'"  :urls="'three-way-handshake.jpg'"/>
+ 服务端创建传输控制块TCB，准备接受客户端连接请求，然后处于LISTEN状态；
+ 客户端的TCP客户进程创建传输控制块TCB，SYN=1，seq=x，发送请求建立连接报文，进入SYN-SENT状态，该报文不能携带数据，但要消耗一个序列号；
+ 服务端收到请求报文后，若同意建立连接，则置SYN=1，ACK=1，ack=x+1，seq=y，发送确认连接报文，服务端进入SYN-RCVD状态。这个报文段也不能携带数据，但要消耗一个序号；
+ 客户端收到确认连接报文后，也要给出确认。置ACK=1，ack=y+1，seq=y+1，发送确认报文后，进行ESTABLISHED状态。这个报文段可以携带数据，如果不携带数据则不消耗序列号。
+ 服务端收到确认后也进入ESTABLISHED状态。

::: warning
最后一次确认报文是为了防止已失效的连接请求报文突然又传送到了客户端，产生错误。
:::
#### 7.2 四报文挥手释放连接
<Common-Thumb :prefix="'/img/theory/computer-network'" :urls="'connection-release.jpg'"/>
+ 客户端进程向TCP发出释放连接报文段，停止发送数据，主动关闭TCP连接，置FIN=1，seq=u，进入FIN-WAIT-1状态。FIN报文段即使不携带数据，也要消耗一个序号；
+ 服务端收到释放报文段后即发出确认，置ack=u+1，ACK=1，seq=v，这时服务端进入CLOSE-WAIT状态。TCP连接进入半关闭状态，即客户端已经没有数据要发送了，但服务端要发送数据，客户端仍然要接收。
+ 若服务端也没有数据要发送了，则向客户端发送连接释放报文，置FIN=1，seq=w，ack=u+1，服务端进入LST-ACK状态；
+ 客户端收到服务端的连接释放报文仍要给出确认，置ACK=1，seq=u+1，ack=w+1，然后进入TIME-WAIT状态。等待2MSL时间后，客户端进入CLOSE状态。
::: warning
为什么要等待2MSL的时间呢？
一是为了保证最后一个ACK报文段能够到达服务端。如果最后一个ACK报文段超时了，服务端还可以进行重传，这时客户端还可以进行确认，如果不等待2MSL时间，客户端就收不到服务端的重传报文，导致无法进行确认；
二是为了防止已失效的连接请求报文段出现在新的连接中。
:::

::: warning
除了时间等待计时器外，TCP还设有一个保活计时器。假设客户端已和服务端建立TCP连接，但客户端主机突然崩溃，这时服务端不能白白等待下去。服务端每收到一次客户端的数据，就重新设置一下保活计时器，时间通常是两小时，若两小时没有收到客户端的数据，就发送一个探测报文，以后每隔75分钟发送一次，若连续发送10个探测报文都没响应，服务端就关闭连接。
:::
